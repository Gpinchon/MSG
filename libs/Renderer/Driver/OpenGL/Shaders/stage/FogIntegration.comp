#include <Bindings.glsl>
#include <Camera.glsl>
#include <Fog.glsl>
#include <FrameInfo.glsl>
#include <Functions.glsl>

layout(
    local_size_x = FOG_WIDTH / FOG_WORKGROUPS,
    local_size_y = FOG_HEIGHT / FOG_WORKGROUPS,
    local_size_z = FOG_DEPTH / FOG_WORKGROUPS) in;

layout(binding = UBO_FRAME_INFO) uniform FrameInfoBlock
{
    FrameInfo u_FrameInfo;
};
layout(binding = UBO_FOG_CAMERA) uniform CameraBlock
{
    Camera u_Camera;
    Camera u_Camera_Previous;
};
layout(binding = UBO_FOG_SETTINGS) uniform FogSettingsBlock
{
    FogSettings u_FogSettings;
};

layout(binding = 0) uniform sampler3D u_ScatteringExtinction;
layout(binding = 1) uniform sampler3D u_DensityNoise;
layout(binding = 0, rgba16f) restrict writeonly uniform image3D img_Result;
layout(binding = 1, rgba16f) restrict readonly uniform image3D img_Result_Previous;

float BeerLaw(IN(float) a_Density, IN(float) a_StepSize)
{
    return exp(-a_Density * a_StepSize);
}

float BeerLaw(IN(float) a_Density)
{
    return BeerLaw(a_Density, 1);
}

vec4 AccumulateScattering(IN(vec4) a_Front, IN(vec4) a_Back)
{
    vec3 light = a_Front.rgb + saturate(exp(-a_Front.a)) * a_Back.rgb;
    return vec4(light, a_Front.a + a_Back.a);
}

vec3 GetWorldPos(IN(vec2) a_UV, IN(float) a_Depth)
{
    const mat4x4 invVP = inverse(u_Camera.projection * u_Camera.view);
    const vec3 uv      = vec3(a_UV, a_Depth);
    const vec3 NDCPos  = uv * 2.f - 1.f;
    const vec4 projPos = (invVP * vec4(NDCPos, 1));
    return projPos.xyz / projPos.w;
}

vec4 FogScatteredExtinction(IN(vec3) a_UVW, IN(vec3) a_WorldPos)
{
    const float densityNoise       = texture(u_DensityNoise, a_WorldPos * u_FogSettings.noiseDensityScale)[0] + (1 - u_FogSettings.noiseDensityIntensity);
    const vec4 scatteredExtinction = texture(u_ScatteringExtinction, a_UVW);
    return vec4(scatteredExtinction.rgb, scatteredExtinction.a * densityNoise);
}

void main()
{
    const mat4x4 VP       = u_Camera.projection * u_Camera.view;
    const mat4x4 invVP    = inverse(VP);
    const vec3 resultSize = textureSize(u_ScatteringExtinction, 0);
    const vec3 texCoord   = gl_GlobalInvocationID + vec3(0.5f);
    const vec2 uv         = texCoord.xy / resultSize.xy;
    const float maxZ      = texCoord.z / resultSize.z;

    const vec3 NDCStartPos   = FogNDCFromUVW(vec3(uv, 0), u_FogSettings.depthExponant);
    const vec4 projStartPos  = invVP * vec4(NDCStartPos, 1);
    vec3 worldPos            = projStartPos.xyz / projStartPos.w;
    vec3 accumScattering     = vec3(0);
    float accumTransmittance = 1.f;
    for (float i = 1; i <= FOG_STEPS; i++) {
        vec3 uvw                  = vec3(uv, i / FOG_STEPS * maxZ);
        const vec3 NDC            = FogNDCFromUVW(uvw, u_FogSettings.depthExponant);
        const vec4 projPos        = invVP * vec4(NDC, 1);
        const vec3 worldPosNext   = projPos.xyz / projPos.w;
        const float worldStepSize = distance(worldPos, worldPosNext);

        const vec4 sliceScatteringExtinction = FogScatteredExtinction(uvw, worldPos);
        const vec3 sliceScattering           = sliceScatteringExtinction.rgb;
        const float sliceExtinction          = max(sliceScatteringExtinction.a, 0.0000001f);
        const float sliceTransmittance       = BeerLaw(sliceExtinction, worldStepSize);
        const vec3 sliceScatteringIntegral   = sliceScattering * (1 - sliceTransmittance) / sliceExtinction;
        accumScattering += sliceScatteringIntegral * accumTransmittance;
        accumTransmittance *= sliceTransmittance;
        worldPos = worldPosNext;
    }
    vec4 out_Color = vec4(accumScattering, accumTransmittance);

#if 0
    {
        const mat4x4 VP_Previous      = u_Camera_Previous.projection * u_Camera_Previous.view;
        const vec4 projPos_Previous   = VP_Previous * vec4(worldPos, 1);
        const vec3 NDCPos_Previous    = projPos_Previous.xyz / projPos_Previous.w;
        const vec3 UVPos_Previous     = (NDCPos_Previous * 0.5f + 0.5f);
        const vec3 fragCoord_Previous = UVPos_Previous * imageSize(img_Result_Previous);
        const vec4 color_Previous     = imageLoad(img_Result_Previous, ivec3(fragCoord_Previous));
        if (color_Previous.a > 0 && all(greaterThanEqual(UVPos_Previous, vec3(0))) && all(lessThanEqual(UVPos_Previous, vec3(1))))
            out_Color = mix(out_Color, color_Previous, 0.5);
    }
#endif
    imageStore(img_Result, ivec3(texCoord), out_Color);
}
