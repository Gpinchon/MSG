#include <Bindings.glsl>
#include <Camera.glsl>
#include <Fog.glsl>
#include <FrameInfo.glsl>
#include <Functions.glsl>

layout(
    local_size_x = FOG_WIDTH / FOG_WORKGROUPS,
    local_size_y = FOG_HEIGHT / FOG_WORKGROUPS,
    local_size_z = FOG_DEPTH / FOG_WORKGROUPS) in;

layout(binding = UBO_FRAME_INFO) uniform FrameInfoBlock
{
    FrameInfo u_FrameInfo;
};
layout(binding = UBO_FOG_CAMERA) uniform CameraBlock
{
    Camera u_Camera;
    Camera u_Camera_Previous;
};
layout(binding = UBO_FOG_SETTINGS) uniform FogSettingsBlock
{
    FogSettings u_FogSettings;
};

layout(binding = 0) uniform sampler3D u_ScatteringExtinction;
layout(binding = 1) uniform sampler3D u_DensityNoise;
layout(binding = 2) uniform sampler3D u_Result_Previous;
layout(binding = 0, rgba16f) restrict writeonly uniform image3D img_Result;

float BeerLaw(IN(float) a_Density, IN(float) a_StepSize)
{
    return exp(-a_Density * a_StepSize);
}

float BeerLaw(IN(float) a_Density)
{
    return BeerLaw(a_Density, 1);
}

vec4 AccumulateScattering(IN(vec4) a_Front, IN(vec4) a_Back)
{
    vec3 light = a_Front.rgb + saturate(exp(-a_Front.a)) * a_Back.rgb;
    return vec4(light, a_Front.a + a_Back.a);
}

vec3 GetWorldPos(IN(vec2) a_UV, IN(float) a_Depth)
{
    const mat4x4 invVP = inverse(u_Camera.projection * u_Camera.view);
    const vec3 uv      = vec3(a_UV, a_Depth);
    const vec3 NDCPos  = uv * 2.f - 1.f;
    const vec4 projPos = (invVP * vec4(NDCPos, 1));
    return projPos.xyz / projPos.w;
}

vec4 FogScatteredExtinction(IN(vec3) a_UVW, IN(vec3) a_WorldPos, IN(float) a_WorldDistToCam)
{
    const vec3 densityUV           = (a_WorldPos + u_FogSettings.noiseDensityOffset) * u_FogSettings.noiseDensityScale;
    const float densityNoiseOffset = (1 - u_FogSettings.noiseDensityIntensity);
    const float densityNoiseAtt    = max(u_FogSettings.noiseDensityMaxDist, a_WorldDistToCam) / u_FogSettings.noiseDensityMaxDist;
    const float densityNoise       = densityNoiseAtt * (texture(u_DensityNoise, densityUV)[0] + densityNoiseOffset);
    const vec4 scatteredExtinction = texture(u_ScatteringExtinction, a_UVW);
    return vec4(scatteredExtinction.rgb, scatteredExtinction.a * densityNoise);
}

void main()
{
    const mat4x4 VP       = u_Camera.projection * u_Camera.view;
    const mat4x4 invVP    = inverse(VP);
    const vec3 resultSize = textureSize(u_ScatteringExtinction, 0);
    const vec3 texCoord   = gl_GlobalInvocationID + vec3(0.5f);
    const vec2 uv         = texCoord.xy / resultSize.xy;
    const float maxZ      = texCoord.z / resultSize.z;

    const vec3 NDCStartPos   = FogNDCFromUVW(vec3(uv, 0), u_FogSettings.depthExponant);
    const vec4 projStartPos  = invVP * vec4(NDCStartPos, 1);
    vec3 worldPos            = projStartPos.xyz / projStartPos.w;
    float worldDist          = 0.f;
    vec3 accumScattering     = vec3(0);
    float accumTransmittance = 1.f;
    // TODO test less bruteforce methods by calculating once for each pixel
    for (float i = 1; i <= FOG_STEPS; i++) {
        vec3 uvw                  = vec3(uv, i / float(FOG_STEPS) * maxZ);
        const vec3 NDC            = FogNDCFromUVW(uvw, u_FogSettings.depthExponant);
        const vec4 projPos        = invVP * vec4(NDC, 1);
        const vec3 worldPosNext   = projPos.xyz / projPos.w;
        const float worldStepSize = distance(worldPos, worldPosNext);
        worldDist += worldStepSize;

        const vec4 sliceScatteringExtinction = FogScatteredExtinction(uvw, worldPos, worldDist);
        const vec3 sliceScattering           = sliceScatteringExtinction.rgb;
        const float sliceExtinction          = max(sliceScatteringExtinction.a, 0.0000001f);
        const float sliceTransmittance       = BeerLaw(sliceExtinction, worldStepSize);
        const vec3 sliceScatteringIntegral   = sliceScattering * (1 - sliceTransmittance) / sliceExtinction;
        accumScattering += sliceScatteringIntegral * accumTransmittance;
        accumTransmittance *= sliceTransmittance;
        worldPos = worldPosNext;
    }
    vec4 out_Color = vec4(accumScattering, accumTransmittance);

    {
        const vec3 NDCCur           = FogNDCFromUVW(texCoord / resultSize, u_FogSettings.depthExponant);
        const vec4 projCur          = invVP * vec4(NDCCur, 1);
        const vec3 worldPosCur      = projCur.xyz / projCur.w;
        const mat4x4 VP_Previous    = u_Camera_Previous.projection * u_Camera_Previous.view;
        const vec4 projPos_Previous = VP_Previous * vec4(worldPosCur, 1);
        const vec3 NDCPos_Previous  = projPos_Previous.xyz / projPos_Previous.w;
        const vec3 UVPos_Previous   = FogUVWFromNDC(NDCPos_Previous, u_FogSettings.depthExponant);
        const vec4 color_Previous   = texture(u_Result_Previous, UVPos_Previous);
        if (color_Previous.a > 0 && all(greaterThanEqual(UVPos_Previous, vec3(0))) && all(lessThanEqual(UVPos_Previous, vec3(1))))
            out_Color = mix(out_Color, color_Previous, 0.5);
    }
    imageStore(img_Result, ivec3(texCoord), out_Color);
}
